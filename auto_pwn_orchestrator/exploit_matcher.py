from __future__ import annotations

import json
import logging
import re
from pathlib import Path
from typing import Any

logger = logging.getLogger(__name__)


class ExploitMatcher:
    def __init__(self, db_path: Path):
        self.db_path = db_path
        self.rules = self._load_rules()

    def _load_rules(self) -> list[dict]:
        if not self.db_path.exists():
            logger.warning(f"Exploit DB not found at {self.db_path}")
            return []
        try:
            return json.loads(self.db_path.read_text())
        except Exception as e:
            logger.error(f"Failed to load exploit DB: {e}")
            return []

    def match(self, service: str, version: str) -> list[dict]:
        matches = []
        for rule in self.rules:
            if rule["service"].lower() in service.lower():
                if re.search(rule["version_regex"], version):
                    matches.append(rule)
        return matches

    def find_exploits_for_host(self, nmap_host_data: dict) -> list[dict]:
        """
        Analyzes a single host's Nmap data and returns potential exploits.
        """
        potential_exploits = []
        
        # Nmap data structure usually: {'tcp': {80: {'product': 'Apache', 'version': '2.4'}, ...}}
        tcp_ports = nmap_host_data.get('tcp', {})
        
        for port, info in tcp_ports.items():
            service = info.get('product', '')
            version = info.get('version', '')
            
            if not service:
                service = info.get('name', '') # Fallback to service name if product is empty

            matched_rules = self.match(service, version)
            for rule in matched_rules:
                potential_exploits.append({
                    "port": port,
                    "service": service,
                    "version": version,
                    "module": rule["module"],
                    "check_module": rule.get("check_module"),
                    "rank": rule.get("rank")
                })
                
        return potential_exploits
